<prompt_overview>
このプロンプトは、仮説検証型のMVP（Minimum Viable Product）を自動生成します。

**コンセプト**: 単なる「便利なアプリ」ではなく、特定の仮説を検証するための最小限の機能を持つプロトタイプ
**実行方法**: Phase1→Phase2→Phase3→Phase4→Phase5を自動連続実行（ユーザー入力待ちなし）
**所要時間**: 約10〜20分（アプリの複雑さによる）
**成果物**: 即座に動作可能なNext.js + TypeScript + Tailwind CSSアプリケーション

**特徴**:
- 🎯 仮説検証を目的とした機能設計（「あると便利」な機能は排除）
- 💎 既存ツールとの明確な差別化ポイント
- 📊 成功指標を測定可能なデータ構造
- 🚀 検証に必要な最小限の実装（スピード優先）
</prompt_overview>

<context_information>
<execution_instructions>
🚨 重要: このプロンプトは自動継続実行型です 🚨

- **ユーザーの入力を待たずに、Phase1からPhase5まで連続して実行してください**
- 各フェーズ完了時に「Phase X 完了。Phase Y を開始します。」と宣言し、即座に次のフェーズを実行
- 途中で止まらず、必ず Phase5 まで完走してください
- completion_criteriaは確認のみで、すべて満たされていると想定して次に進んでください
- **Phase5完了後のみ「全フェーズ完了」と宣言してください**

実行フロー:
Phase1(分析) → 即座に → Phase2(セットアップ) → 即座に → Phase3(基本ページ) → 即座に → Phase4(コア機能) → 即座に → Phase5(最終調整)
</execution_instructions>

<role>
あなたは経験豊富なフルスタックエンジニアです。
ユーザーが指定するアプリケーション要件に基づいて、完全に動作するモックWebサイトをNext.jsで構築してください。

🚨 **重要**: このタスクはPhase1からPhase5まで自動で連続実行してください。途中で止まらないでください。🚨
</role>

<application_requirements>
{ここに作成したいアプリケーションの詳細を入力してください}

💡 推奨記載内容：
1. **解決したい課題**: ターゲットユーザーが抱えている具体的な問題
2. **提案する解決策**: この課題をどのように解決するか（仮説）
3. **既存の方法との違い**: 現在ユーザーがどう対処しており、なぜそれが不十分か
4. **検証したいこと**: このアプリで何を確認/測定したいか
5. **ターゲットユーザー**: 誰がこのアプリを使うか

例：
「フリーランスデザイナーは、プロジェクトの見積もり作成に時間がかかりすぎる。
現在はExcelやGoogleスプレッドシートで計算しているが、過去の案件データを参照したり、
類似案件から推定するのが面倒。このアプリは、過去の案件データから自動で見積もりを
生成することで、見積もり時間を80%削減できるという仮説を検証したい。」

**注**: 単に「タスク管理アプリを作りたい」ではなく、「なぜ既存のツールでは不十分なのか」を明確にしてください。
</application_requirements>

<technical_stack>
以下の技術スタックを使用してください：
- Next.js 14+ (App Router構成)
- TypeScript（厳格な型定義）
- Tailwind CSS（スタイリング）
- shadcn/ui（UIコンポーネントライブラリ）
- Framer Motion（アニメーション）
- Lucide React（アイコン）
</technical_stack>

<architecture_constraints>
外部依存を排除したシンプルな構成：
1. **データベース不使用**: すべてのデータ永続化はLocalStorageで実装
2. **API不使用**: サーバーサイドAPIコールは不要
3. **認証システム**: ダミーログイン（コード内にユーザー情報を定義）
4. **即時動作**: npm installとnpm run devで即座に動作すること
</architecture_constraints>

<ui_ux_guidelines>
- **モダンでプロフェッショナルなデザイン**: 2025年のトレンドを反映
- **完全レスポンシブ**: モバイル、タブレット、デスクトップすべてに対応
- **マイクロインタラクション**: ボタンホバー、ローディング状態、トランジション
- **アニメーション**: Framer Motionで滑らかなページ遷移とフェードイン効果
- **日本語コンテンツ**: すべてのテキストは日本語で記述
- **アクセシビリティ**: セマンティックHTML、適切なARIA属性、キーボード操作対応
- **カラースキーム**: 統一感のある配色（Tailwindのカラーパレットを活用）
</ui_ux_guidelines>

<code_quality_standards>
- **TypeScript厳格モード**: すべての型を明示的に定義
- **エラーハンドリング**: try-catch、エラーバウンダリーの実装
- **ローディング状態**: データ取得中の適切なUI表示
- **コメント**: 複雑なロジックには日本語コメントを追加
- **フォーマット**: Prettier準拠のコード整形
- **命名規則**: 一貫性のある変数名、関数名（日本語コメントで意図を明示）
</code_quality_standards>

<asset_handling>
- 画像はプレースホルダーサービスを使用（https://placehold.co/ 推奨）
- アイコンはLucide Reactから選択
- 必要に応じてUnsplash APIの無料画像を参照可能
</asset_handling>
</context_information>

<execution_phases>

<phase1_tasks>
<role>
あなたはプロダクトストラテジストとして、アプリケーション要件を分析し、「検証すべき仮説」と「それを検証するための最小限の機能」を特定します。
</role>

<task>
<application_requirements>を精査し、以下を段階的に分析してください：

## ステップ1: 課題と仮説の抽出

要件から以下を特定：
1. **解決したい課題**: ユーザーが直面している具体的な問題
2. **ターゲットユーザー**: 誰がこの課題を抱えているか
3. **提案する解決策（仮説）**: この課題をどう解決するか
4. **仮説の核心**: なぜこの解決策が有効だと考えるか

**重要**: 「タスク管理アプリ」のような既存カテゴリに当てはめるのではなく、要件固有の価値提案を見つけてください。

## ステップ2: 仮説検証のための検証ポイント特定

仮説を検証するために、以下の問いに答えてください：
- **検証したいこと1**: ユーザーはこの課題を本当に重要だと感じるか？
  - 検証方法: [どの機能/データで確認するか]
  
- **検証したいこと2**: 提案する解決策は実際に使われるか？
  - 検証方法: [どの機能/データで確認するか]
  
- **検証したいこと3**: この解決策は既存の方法より優れているか？
  - 検証方法: [どの機能/データで確認するか]

## ステップ3: MVP機能の特定（2〜3つに絞る）

検証ポイントから逆算し、**検証に必要な最小限の機能**のみを選定：

各機能について：
- **機能名**: [検証のための機能名]
- **検証する仮説**: [この機能で何を検証するか]
- **成功の指標**: [何が測定できれば仮説が検証されたとわかるか]
- **必要な要素**: [この機能を実現するための具体的な要素]

**重要**: 「あると便利」ではなく「検証に必須」の機能だけを選んでください。

## ステップ4: ユニークな価値の明確化

このアプリケーションが既存の解決策（Excel、メモ、既存ツール等）と比べて優れている点：
1. [ユニークポイント1]
2. [ユニークポイント2]

分析結果を `/product/construction/analysis.md` に記載してください。
</task>

<output_format>
# 仮説検証型アプリケーション設計書

## 1. 課題と仮説

### 解決したい課題
[ユーザーが直面している具体的な問題を記述]

### ターゲットユーザー
- **プライマリユーザー**: [主要ユーザーの詳細]
- **セカンダリユーザー**: [該当する場合]
- **ユーザーの現在の解決方法**: [現在どのように課題に対処しているか]

### 提案する解決策（仮説）
**仮説文**: 「[ターゲットユーザー]は、[課題]に対して、[提案する解決策]を使うことで、[期待される成果]を得られる」

**仮説の核心**: 
[なぜこの解決策が既存の方法より優れていると考えるか]

### ユニークバリュー
このアプリが既存の解決策と比べて優れている点：
1. **[ユニークポイント1]**: [説明]
2. **[ユニークポイント2]**: [説明]

---

## 2. 仮説検証ポイント

### 検証ポイント1: 課題の重要性
**検証したいこと**: ユーザーはこの課題を本当に重要だと感じるか？
**検証方法**: [どの機能/データでこれを確認するか]
**成功の指標**: [何が測定できれば検証されたか]

### 検証ポイント2: 解決策の有効性
**検証したいこと**: 提案する解決策は実際に使われるか？
**検証方法**: [どの機能/データでこれを確認するか]
**成功の指標**: [何が測定できれば検証されたか]

### 検証ポイント3: 既存方法との比較
**検証したいこと**: この解決策は既存の方法より優れているか？
**検証方法**: [どの機能/データでこれを確認するか]
**成功の指標**: [何が測定できれば検証されたか]

---

## 3. MVP機能（優先度順）

### 機能1: [機能名] 🎯 最優先
**検証する仮説**: [この機能で何の仮説を検証するか]
**成功の指標**: [この機能で何が測定できれば成功か]
**必要な要素**:
- [ ] [要素1: 具体的なUI/機能要素]
- [ ] [要素2: 具体的なUI/機能要素]
- [ ] [要素3: 具体的なUI/機能要素]

**ユーザーフロー**: 
[ユーザーがこの機能をどう使うか、ステップバイステップで記述]

**データモデル**:
```
{
  // この機能に必要なデータ構造
}
```

### 機能2: [機能名]
[同様の形式で記載]

### 機能3: [機能名]（該当する場合）
[同様の形式で記載]

---

## 4. 意図的に含めない機能

以下の機能は検証に不要なため実装しません：
- [含めない機能1]: [理由]
- [含めない機能2]: [理由]

---

## 5. 技術実装の方針

### ページ構成
- `/`: ランディングページ（価値提案とCTA）
- `/login`: シンプルなログイン（デモユーザー）
- `/[メイン機能]`: [機能1のメインページ]
- `/[サブ機能]`: [必要に応じて]

**注**: ダッシュボードは仮説検証に必要な場合のみ実装

### データモデル
```typescript
// Phase2で実装する型定義の概要
```

### 認証方式
- [単一ユーザー/複数ユーザー種別]
- デモユーザー: [ユーザー情報]

### 主要なカスタムフック
- useLocalStorage
- useAuth
- [機能特有のフック]
</output_format>

<completion_criteria>
✅ Phase1完了条件（簡潔版）:
- `/product/construction/analysis.md` が作成されている
- 仮説文が明確に記載されている
- 3つの検証ポイントが定義されている
- MVP機能が2〜3つ特定され、各機能が「検証する仮説」と紐づいている
- 既存の解決策との差別化ポイントが明確

**品質チェック**:
- [ ] 「タスク管理」「顧客管理」などの汎用的なカテゴリに収まっていない
- [ ] 各機能が「あると便利」ではなく「検証に必須」として選定されている
- [ ] ユニークバリューが具体的で、既存ツール（Excel、メモ等）との違いが明確

**完了宣言**: 「✅ Phase1完了。Phase2を開始します。」と宣言し、即座にPhase2に進んでください。
</completion_criteria>
</phase1_tasks>

<phase2_tasks>
<role>
あなたはシニアエンジニアとして、プロジェクトのセットアップと基盤実装を行います。
</role>

<task>
以下の手順でプロジェクトをセットアップしてください：

1. **Next.jsプロジェクトの作成**
   ```bash
   cd /Users/yutaokos/src/aws-samples/aws-ml-enablement-workshop/yourwork_20251016/
   npx create-next-app@latest product --typescript --tailwind --app --src-dir --import-alias "@/*"
   ```

2. **依存関係のインストール**
   ```bash
   cd product
   npm install framer-motion lucide-react
   ```

3. **shadcn/uiのセットアップ**
   必要なコンポーネントをインストール（Button, Card, Input, Form, Dialog, Toast等）

4. **プロジェクト構造の構築**
   ```
   /product/
   ├── src/
   │   ├── app/
   │   │   ├── page.tsx
   │   │   ├── login/page.tsx
   │   │   ├── dashboard/page.tsx
   │   │   └── layout.tsx
   │   ├── components/
   │   │   ├── ui/              # shadcn/ui
   │   │   ├── auth/
   │   │   ├── layout/
   │   │   └── features/
   │   ├── lib/
   │   │   ├── hooks/
   │   │   ├── utils.ts
   │   │   └── constants.ts
   │   ├── types/
   │   │   └── index.ts
   │   └── context/
   │       └── AuthContext.tsx
   ├── construction/
   │   └── analysis.md        # Phase1で作成
   └── README.md
   ```

5. **基盤機能の実装**
   - TypeScript型定義（`types/index.ts`）
   - Phase1の`analysis.md`で定義したデータモデルを実装
   - LocalStorage管理フック（`lib/hooks/useLocalStorage.ts`）
   - 認証Context（`context/AuthContext.tsx`）
   - Phase1で特定したユーザー種別に対応
   - 認証フック（`lib/hooks/useAuth.ts`）
   - サンプルデータ生成関数（`lib/data/seed.ts`）
   - Phase1で特定したコア機能に必要なダミーデータを生成
</task>

<completion_criteria>
✅ Phase2完了条件（簡潔版）:
- Next.jsプロジェクトが作成され、基盤ファイル（型定義、hooks、Context）が実装されている
- `npm run dev`で起動可能な状態

**完了宣言**: 「✅ Phase2完了。Phase3を開始します。」と宣言し、即座にPhase3に進んでください。
</completion_criteria>
</phase2_tasks>

<phase3_tasks>
<role>
あなたはフロントエンドエンジニアとして、基本ページを実装します。
</role>

<task>
以下の基本ページを実装してください：

1. **ランディングページ (`app/page.tsx`)**
   - **Phase1で定義した課題と解決策（仮説）を伝えるヒーローセクション**
   - **ユニークバリューの説明**（既存の方法との違いを明確に）
   - 主要機能の説明（2〜3セクション、Phase1で定義したMVP機能）
   - CTAボタン（「今すぐ試す」→ログインページへ）
   - スムーズなスクロールアニメーション（Framer Motion）
   
   **重要**: 単なる機能紹介ではなく、「なぜこのアプリが必要か」を訴求してください。

2. **ログインページ (`app/login/page.tsx`)** - ダミー実装で十分
   - シンプルなログインフォーム（メールアドレスのみでOK）
   - **デモユーザー情報を画面上に見やすく表示**（クリックで入力できると親切）
   - ボタンをクリックするだけでログイン完了（パスワード不要でも可）
   - ログイン後はメイン機能ページへリダイレクト
   - Phase1で特定したユーザー種別がある場合は、各種別のデモアカウントをリスト表示
   
   **重要**: バリデーションやエラーハンドリングは最小限で構いません。
   デモ体験を素早くスムーズにすることを優先してください。

3. **メインページ（ダッシュボードまたはコア機能ページ）**
   - ログイン必須（RouteGuard実装）
   - ナビゲーションバー
   - **Phase1で定義したMVP機能へのアクセス**
   
   **重要**: 
   - 伝統的な「ダッシュボード」にこだわる必要はありません
   - Phase1の分析で、ダッシュボードが仮説検証に不要と判断された場合は、コア機能ページを直接表示してください
   - 統計情報は、仮説検証に必要な場合のみ実装してください

4. **共通レイアウト (`app/layout.tsx`)**
   - ルートレイアウトの実装
   - 認証Providerの設定
   - ToastProviderの設定
   - グローバルスタイルの適用

5. **共通コンポーネント**
   - Header / Navigation
   - Sidebar（該当する場合）
   - RouteGuard（認証チェック）
   - RoleGuard（ユーザー種別チェック、必要な場合）
</task>

<completion_criteria>
✅ Phase3完了条件（簡潔版）:
- ランディング、ログイン、ダッシュボードページが実装され、ページ遷移が動作する
- レスポンシブデザインが適用されている

**完了宣言**: 「✅ Phase3完了。Phase4を開始します。」と宣言し、即座にPhase4に進んでください。
</completion_criteria>
</phase3_tasks>

<phase4_tasks>
<role>
あなたはフルスタックエンジニアとして、Phase1で特定したMVP機能を完全に実装します。
</role>

<task>
Phase1の `analysis.md` で特定した2〜3つのMVP機能を、優先度順に実装してください。

**重要な原則**:
1. **仮説検証が目的**: 各機能は「検証する仮説」を明確に意識して実装
2. **データ収集を意識**: 成功の指標を測定できるようなデータ構造にする
3. **ユニークバリューを体現**: 既存ツールとの差別化ポイントを機能に反映
4. **シンプルさ優先**: 検証に不要な機能は実装しない

**実装前の確認**:
- [ ] 各機能が「あると便利」ではなく「検証に必須」である
- [ ] 各機能がPhase1で定義した「検証する仮説」と紐づいている
- [ ] 各機能で「成功の指標」が測定可能である

## 実装手順

### 各コア機能について：

1. **データモデルの実装**
   - TypeScript型定義
   - LocalStorageのキー定義
   - 初期サンプルデータの準備

2. **必要な要素の実装**
   Phase1で定義したチェックリストの各要素を実装：
   
   例（データ管理型の場合）:
   - [ ] データ一覧表示ページ/コンポーネント
   - [ ] 詳細表示ページ/コンポーネント
   - [ ] 作成・編集フォーム
   - [ ] 削除機能と確認ダイアログ
   - [ ] 検索・フィルタリング機能
   - [ ] ソート機能
   - [ ] ページネーション
   
   例（ツール型の場合）:
   - [ ] 入力フォームコンポーネント
   - [ ] 処理ロジックの実装
   - [ ] 結果表示コンポーネント
   - [ ] 履歴表示機能
   - [ ] 設定保存機能

3. **カスタムフックの実装**
   機能に特化したカスタムフック：
   - データ取得・更新フック
   - 検索・フィルタフック
   - その他必要なロジック

4. **完全なユーザーフローの実装**
   Phase1で定義したユーザーフローが実際に動作することを確認：
   - 入力から出力まで完結する
   - LocalStorageへの保存・読み込みが機能する
   - ページリロード後もデータが保持される
   - 適切なフィードバック（トースト通知等）
   - バリデーションとエラーハンドリング

5. **ダッシュボードとの統合**
   - ダッシュボードからコア機能へのナビゲーション追加
   - ダッシュボードでのサマリー表示（該当する場合）

## 実装の柔軟性

アプリケーションの種別に応じて、最適な実装方法を選択してください：

**ルーティング**:
- `/feature-name` （一覧）
- `/feature-name/[id]` （詳細）
- `/feature-name/new` （新規作成）
- モーダルで作成・編集する場合は、動的ルートは不要

**データ表示**:
- テーブル形式（データ量が多い場合）
- カード形式（視覚的な情報が重要な場合）
- リスト形式（シンプルな項目の場合）

**フォーム実装**:
- 専用ページ（複雑なフォームの場合）
- モーダル/ダイアログ（シンプルなフォームの場合）
- サイドパネル（コンテキストを保持したい場合）
</task>

<completion_criteria>
✅ Phase4完了条件（簡潔版）:
- Phase1で特定したMVP機能（2〜3つ）が実装され、実際に動作する
- 各機能で「成功の指標」が測定できるデータが保存される
- Phase1で定義した「ユニークバリュー」が機能に反映されている
- LocalStorageでデータが永続化され、必要な操作が可能

**品質チェック**:
- [ ] 各機能が仮説検証に必要十分な実装になっている（過不足ない）
- [ ] 既存ツール（Excel、メモ等）との差別化ポイントが明確に体現されている
- [ ] データ構造が「成功の指標」の測定を可能にしている

**完了宣言**: 「✅ Phase4完了。Phase5を開始します。」と宣言し、即座にPhase5に進んでください。
</completion_criteria>
</phase4_tasks>

<phase5_tasks>
<role>
あなたはQAエンジニアとして、アプリケーション全体の動作確認と最終調整を行います。
</role>

<task>
以下の最終調整とテストを実施してください：

1. **統合テスト**
   - 全てのユーザーフローを実際に操作して確認
   - ログイン → 各機能の使用 → ログアウト
   - データの作成 → 表示 → 編集 → 削除（該当する場合）
   - ページリロード後のデータ永続化確認

2. **レスポンシブデザインの確認**
   - モバイル（375px、414px）
   - タブレット（768px、1024px）
   - デスクトップ（1280px、1920px）
   - すべてのページとコンポーネントで確認

3. **エラーハンドリングの確認**
   - コア機能での不正な入力値のバリデーション
   - 存在しないIDへのアクセス
   - LocalStorageが無効な場合の動作
   
   **注**: ログインページのバリデーションは最小限で構いません（ダミー実装のため）

4. **パフォーマンス最適化**
   - 不要な再レンダリングの防止
   - 画像の最適化
   - コンポーネントの遅延読み込み（必要な場合）

5. **ユーザビリティ改善**
   - ローディング状態の追加
   - エラーメッセージの改善
   - トースト通知のタイミング調整
   - アニメーションの微調整

6. **ドキュメント作成**
   `/product/README.md` に以下を記載：
   - **プロジェクト概要**（解決する課題と仮説を明記）
   - **ユニークバリュー**（既存ツールとの違い）
   - **検証したい仮説**（3つの検証ポイント）
   - **セットアップ手順**
   - **デモユーザー情報**（全ユーザー種別）
   - **実装済みMVP機能**（各機能が検証する仮説を明記）
   - **成功指標の確認方法**（どのデータを見れば仮説が検証できるか）
   - **技術スタック**
   - **ディレクトリ構造**

7. **ビルド確認**
   ```bash
   npm run build
   ```
   エラーなくビルドが成功することを確認
</task>

<completion_criteria>
✅ Phase5完了条件（簡潔版）:
- `npm run build`が成功する
- README.mdが作成され、セットアップ手順とデモユーザー情報が記載されている
- 全コア機能が動作し、レスポンシブデザインが適用されている

**最終宣言**: 「🎉 Phase5完了。全フェーズが正常に完了しました！」と宣言してください。
</completion_criteria>
</phase5_tasks>

</execution_phases>

<important_notes>
🚨 **実行モード: 自動継続型** 🚨

- **ユーザーの入力を待たずに、Phase1→Phase2→Phase3→Phase4→Phase5を連続実行してください**
- 各フェーズ完了時は即座に次のフェーズに進み、Phase5完了まで止まらないでください
- completion_criteriaは参考情報であり、厳密に全項目をチェックする必要はありません
- Phase1の分析結果に基づいて、Phase4の実装内容が変わります
- 各機能が「実際に動作する」ことを最優先してください

**🎯 仮説検証ファーストの原則**:
1. **目的は仮説検証**: 単なる「便利なアプリ」ではなく、特定の仮説を検証するためのMVP
2. **ユニークバリュー優先**: 既存ツールでできることは避け、差別化ポイントを明確に
3. **測定可能性**: 成功の指標を測定できるデータ構造とUI
4. **最小限の機能**: 検証に不要な機能は勇気を持って削る

**実装の優先順位**:
1. **仮説検証に貢献すること** > あると便利な機能
2. **ユニークバリューの体現** > 一般的な機能の網羅
3. **動作すること** > 完璧なコード
4. **シンプルさ** > 複雑な設計
5. **速度** > 詳細な最適化

**❌ 避けるべきパターン**:
- 「タスク管理アプリ」「顧客管理アプリ」などの汎用カテゴリへの収束
- 伝統的な「ダッシュボード」へのこだわり（検証に不要なら不要）
- CRUD操作の完全な実装（検証に必要な操作のみ実装）
- 既存ツール（Excel、Notion等）で代替できる機能
- 「あると便利」な補助機能の追加

**ログイン機能について**:
- ログインは完全なダミー実装で構いません
- デモユーザー情報を見やすく表示し、ワンクリックでログインできるようにしてください
- 複雑なバリデーションやエラーハンドリングは不要です
- 重要なのはコア機能の実装であり、ログインはあくまで認証状態を作るための簡易的な手段です

**プログレス表示**:
各フェーズ開始時に以下を表示してください：
- Phase1開始: 「📋 Phase1: 要件分析を開始します」
- Phase2開始: 「🛠️ Phase2: プロジェクトセットアップを開始します」
- Phase3開始: 「🎨 Phase3: 基本ページ実装を開始します」
- Phase4開始: 「⚡ Phase4: コア機能実装を開始します」
- Phase5開始: 「✨ Phase5: 最終調整を開始します」
- Phase5完了: 「🎉 全フェーズ完了！アプリケーションが使用可能です」

**v0での使用について**:
このプロンプトをv0で使用する場合：
1. `<application_requirements>`にアプリケーションの詳細を記入してから送信
2. プロンプト送信後、AIが自動的にPhase1〜Phase5を実行するまで待つ
3. もしPhase3やPhase4で止まった場合は、「Phase5まで続けてください」と入力
4. 長いレスポンスになる可能性があるため、タイムアウトが発生する場合があります

**トラブルシューティング**:
- Phase1で止まる場合: 「Phase2からPhase5まで実行してください」
- Phase4で止まる場合: 「Phase5を実行してください」
- ファイルが生成されない場合: 「全ファイルを生成してください」

**🌟 良い要件の例**:
```
要件: エンジニア向けの技術記事執筆支援アプリ

課題: エンジニアはブログ記事を書く際、コードスニペットの管理とプレビューを
何度も行き来する必要がある。現在はMarkdownエディタとブラウザを行き来しているが、
リアルタイムでのコード実行結果を確認しながら記事を書けない。

仮説: コードの実行結果をリアルタイムでプレビューしながら記事を書けるエディタを
使うことで、記事執筆時間を50%削減し、コードの正確性を向上できる。

検証したいこと:
1. エンジニアはコード実行機能付きエディタを実際に使うか
2. リアルタイムプレビューは記事品質を向上させるか
3. 既存のMarkdown + ブラウザより効率的か
```

**❌ 避けるべき要件の例**:
```
要件: タスク管理アプリを作りたい
（汎用的すぎる、課題や仮説が不明確、既存ツールとの違いが不明）
```
</important_notes>
